% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gibbs_bt_sbm.R
\name{gibbs_bt_sbm}
\alias{gibbs_bt_sbm}
\title{Gibbs sampler for the Bradley–Terry Stochastic Block Model (BT–SBM)}
\usage{
gibbs_bt_sbm(
  w_ij,
  a = 4,
  prior = c("DP", "PY", "DM", "GN"),
  alpha_PY = NA_real_,
  sigma_PY = NA_real_,
  beta_DM = NA_real_,
  K_DM = NA_integer_,
  gamma_GN = NA_real_,
  T_iter = 2000,
  T_burn = 1000,
  init_x = NULL,
  store_z = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{w_ij}{Integer or numeric square matrix \eqn{n \times n} of directed wins
(i over j). Must be nonnegative with zero diagonal. The function builds
\eqn{n_{ij} = w_{ij} + w_{ji}} internally.}

\item{a}{Positive shape parameter for the Gamma prior
\eqn{\lambda_k \sim \mathrm{Gamma}(a,b)}. The algorithm uses
\eqn{b = \exp(\psi(a))} so that \eqn{\mathbb{E}[\log \lambda_k] = 0} a priori.}

\item{prior}{Character scalar, one of \code{"DP"}, \code{"PY"}, \code{"DM"}, \code{"GN"}.}

\item{alpha_PY, sigma_PY}{Hyperparameters for Pitman–Yor / Dirichlet Process.
For \code{prior="DP"} use \code{alpha_PY} (with \code{sigma_PY} ignored).
For \code{prior="PY"} use both \code{alpha_PY} and \code{sigma_PY \in (0,1)}.}

\item{beta_DM, K_DM}{Hyperparameters for the finite Dirichlet–Multinomial prior.
\code{K_DM} is the maximum number of allowed clusters.}

\item{gamma_GN}{Hyperparameter for the Gnedin prior.}

\item{T_iter, T_burn}{Integers: total iterations and burn-in. Must satisfy \code{T_burn < T_iter}.}

\item{init_x}{Optional integer vector of length \code{n} with initial labels (1-based).}

\item{store_z}{Logical; if \code{TRUE}, store latent \code{Z} draws (heavy).}

\item{verbose}{Logical; if \code{TRUE}, prints progress every 1000 iterations.}
}
\value{
A \code{list} with:
\itemize{
\item \code{x_samples}: integer matrix \eqn{S \times n} of raw labels (\eqn{S = T_{\mathrm{iter}}-T_{\mathrm{burn}}}).
\item \code{lambda_samples}: list of length \eqn{S}; each element is a numeric vector
of length \eqn{L_{\mathrm{cap}}} for that draw, with \code{NA} at empty labels.
\item \code{K_per_iter}: integer vector length \eqn{S} (occupied cluster count per saved draw).
\item \code{L_cap_per_iter}: integer vector length \eqn{S} (label capacity trace).
\item \code{z_samples}: if \code{store_z=TRUE}, a numeric array \eqn{S \times n \times n}; otherwise \code{NULL}.
}
}
\description{
Runs a Gibbs sampler for the BT–SBM with optional DP/PY/DM/GN priors on
the partition. Returns raw draws plus minimal summaries; \code{n_ij} is
computed internally as \code{w_ij + t(w_ij)}.
}
\details{
Row names of \code{w_ij} (if present) are propagated to item-level outputs;
otherwise items are named \code{Item_1, ..., Item_n}.
}
\examples{
\dontrun{
set.seed(1)
n <- 6L
w <- matrix(0L, n, n)
w[lower.tri(w)] <- rpois(sum(lower.tri(w)), 2)
diag(w) <- 0
rownames(w) <- colnames(w) <- paste0("P", seq_len(n))
fit <- gibbs_bt_sbm(
  w_ij = w, prior = "GN", gamma_GN = 0.5,
  T_iter = 200, T_burn = 100, verbose = FALSE
)
}
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{relabel_by_lambda}
\alias{relabel_by_lambda}
\title{Relabel cluster assignments by decreasing lambda}
\usage{
relabel_by_lambda(x_samples, lambda_samples)
}
\arguments{
\item{x_samples}{Integer matrix S x N of sampled labels (arbitrary ids per iter).}

\item{lambda_samples}{Either:
\itemize{
\item a \strong{list} of length S with numeric vectors indexed by raw label id
(NAs allowed for non-occupied ids), or
\item a \strong{matrix} S x L giving per-iteration \eqn{\lambda_\ell} for label \eqn{\ell}.
}}
}
\value{
A list with components:
\describe{
\item{x_samples_relabel}{S x N integer matrix of relabeled draws (1..K per iter, ordered by \eqn{\lambda}).}
\item{lambda_samples_relabel}{S x N numeric matrix assigning each item its cluster's \eqn{\lambda} after relabeling.}
\item{item_cluster_assignment_probs}{N x Kmax data frame of marginal assignment probabilities.}
\item{block_count_distribution}{Data frame of the distribution of the number of blocks across iterations.}
\item{avg_top_block_count}{Average size of the top-\eqn{\lambda} block.}
\item{co_clustering}{Posterior similarity matrix (N x N).}
\item{minVI_partition}{Hard partition via minVI.}
\item{partition_binder}{Hard partition via Binder's loss.}
\item{n_clusters_each_iter}{Integer vector length S with number of blocks per iteration.}
\item{top_block_count_per_iter}{Integer vector length S with size of the top block per iteration.}
\item{cluster_lambda_ordered}{List length S of ordered \eqn{\lambda} vectors (length K per iter).}
}
}
\description{
Given posterior samples of labels \code{x_samples} (S x N) and corresponding
cluster-level intensities \code{lambda_samples} per iteration, produce a
canonical relabeling where cluster 1 has the largest \eqn{\lambda},
cluster 2 the second largest, etc. Also computes co-clustering summaries
and assignment probabilities.
}
\details{
The function first compacts raw labels to 1..K within each iteration,
then orders the occupied labels by decreasing \eqn{\lambda}, producing a
canonical labeling. Co-clustering summaries use \pkg{mcclust} and \pkg{mcclust.ext}.
}
\examples{
\dontrun{
S <- 100; N <- 20
set.seed(42)
x_samps <- matrix(sample(1:3, S*N, TRUE), S, N)
lam_list <- replicate(S, { v <- rep(NA_real_, 5); v[1:3] <- runif(3, 0.5, 2); v }, simplify=FALSE)
out <- relabel_by_lambda(x_samps, lam_list)
table(out$block_count_distribution$num_blocks)
}
}
